# SPDX-License-Identifier: Apache-2.0

#!/usr/bin/env python3
from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

ROOT = Path(__file__).resolve().parents[1]
LAYER_DATA_PATH = ROOT / "meta" / "layer-control-tables.json"
MATURITY_DATA_PATH = ROOT / "meta" / "v5-maturity.json"
CHAPTER_OUTPUT_DIR = ROOT / "source" / "chapters" / "generated"
APPENDIX_OUTPUT_DIR = ROOT / "source" / "appendices" / "generated"
AEIP_SCHEMA_DIR = ROOT / "schemas" / "aeip"


def ensure_dirs() -> None:
    CHAPTER_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    APPENDIX_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)


def load_json(path: Path) -> dict:
    return json.loads(path.read_text())


def latex_escape(text: str) -> str:
    replacements = {
        "&": r"\&",
        "%": r"\%",
        "#": r"\#",
        "_": r"\_",
    }
    for original, replacement in replacements.items():
        text = text.replace(original, replacement)
    return text


@dataclass
class LayerEntry:
    chapter: str
    slug: str
    purpose: str
    obligations: list[str]
    verification_artefact: str
    aeip_schema: str
    evidence_fields: list[str]
    example_caption: str
    example_language: str
    example_content: str

    @classmethod
    def from_dict(cls, data: dict) -> "LayerEntry":
        example = data["example"]
        return cls(
            chapter=data["chapter"],
            slug=data["slug"],
            purpose=data["purpose"],
            obligations=data["obligations"],
            verification_artefact=data["verification_artefact"],
            aeip_schema=data["aeip_schema"],
            evidence_fields=data["evidence_fields"],
            example_caption=example["caption"],
            example_language=example["language"],
            example_content=example["content"],
        )


def format_item_list(items: Iterable[str]) -> str:
    lines = ["\\begin{itemize}"]
    for item in items:
        lines.append(f"\\item {item}")
    lines.append("\\end{itemize}")
    return "\n".join(lines)


def write_layer_control_tables(layers: list[LayerEntry]) -> None:
    for entry in layers:
        rows = [
            ("Purpose", latex_escape(entry.purpose)),
            ("Obligations", format_item_list(entry.obligations)),
            ("Verification Artefact", latex_escape(entry.verification_artefact)),
            ("AEIP Schema", entry.aeip_schema),
            ("Evidence Fields", format_item_list(entry.evidence_fields)),
        ]
        lines: list[str] = [
            "% \\begin{autogenerated}",
            "\\begin{autogenerated}",
            "\\begin{longtable}{p{0.22\\textwidth}p{0.73\\textwidth}}",
            "\\toprule",
        ]
        for label, value in rows:
            lines.append(f"\\textbf{{{label}}} & {value} \\ ")
            lines.append("\\midrule")
        lines[-1] = "\\bottomrule"
        lines.extend([
            "\\end{longtable}",
            f"\\textbf{{Verification Example}}\\label{{tab:{entry.slug}-verification}}\\par",
            f"\\begin{{lstlisting}}[language={entry.example_language},caption={{Verification artefact for {entry.slug}}},label={{lst:{entry.slug}-example}}]",
            entry.example_content,
            "\\end{lstlisting}",
            "\\end{autogenerated}",
            "% \\end{autogenerated}",
            "",
        ])
        output_path = CHAPTER_OUTPUT_DIR / f"{entry.slug}-control-table.tex"
        output_path.write_text("\n".join(lines))


def write_maturity_tables(data: dict) -> None:
    stages = data.get("stages", [])
    transport = data.get("transport_grid", [])
    lines: list[str] = [
        "% \\begin{autogenerated}",
        "\\begin{autogenerated}",
        "\\subsection*{Maturity Ladder}",
        "\\begin{longtable}{p{0.18\\textwidth}p{0.12\\textwidth}p{0.62\\textwidth}}",
        "\\toprule",
        "\\textbf{Stage} & \\textbf{Governance Integration Index} & \\textbf{Description and Checkpoints} \\ ",
        "\\midrule",
    ]
    for stage in stages:
        name = latex_escape(stage["name"])
        gii = stage.get("governance_integration_index", "")
        description = latex_escape(stage.get("description", ""))
        checkpoints = stage.get("checkpoints", [])
        checkpoint_lines = ["\\begin{itemize}"]
        for checkpoint in checkpoints:
            code = latex_escape(str(checkpoint.get("code", "")))
            metric = latex_escape(checkpoint.get("metric", ""))
            schema = latex_escape(checkpoint.get("aeip_schema", ""))
            evidence = latex_escape(checkpoint.get("evidence", ""))
            checkpoint_lines.append(
                f"\\item [{code}] {metric}\\newline\\textit{{AEIP: {schema}; Evidence: {evidence}}}"
            )
        checkpoint_lines.append("\\end{itemize}")
        lines.append(
            f"{name} & {gii} & {description}\\newline" + "\n".join(checkpoint_lines) + " \\ "
        )
        lines.append("\\midrule")
    lines[-1] = "\\bottomrule"
    lines.extend([
        "\\end{longtable}",
        "\\subsection*{Governance Transport Grid}",
        "\\begin{longtable}{p{0.2\\textwidth}p{0.18\\textwidth}p{0.18\\textwidth}p{0.18\\textwidth}p{0.18\\textwidth}}",
        "\\toprule",
        "\\textbf{Layer} & \\textbf{Emergent} & \\textbf{Structured} & \\textbf{Integrated} & \\textbf{Institutionalized} \\ ",
        "\\midrule",
    ])
    for row in transport:
        layer = latex_escape(row.get("layer", ""))
        emergent = latex_escape(row.get("emergent", ""))
        structured = latex_escape(row.get("structured", ""))
        integrated = latex_escape(row.get("integrated", ""))
        institutionalized = latex_escape(row.get("institutionalized", ""))
        lines.append(
            f"{layer} & {emergent} & {structured} & {integrated} & {institutionalized} \\ "
        )
        lines.append("\\midrule")
    lines[-1] = "\\bottomrule"
    lines.extend([
        "\\end{longtable}",
        "\\end{autogenerated}",
        "% \\end{autogenerated}",
        "",
    ])
    (APPENDIX_OUTPUT_DIR / "appendix-c-maturity-tables.tex").write_text("\n".join(lines))


@dataclass
class SchemaRecord:
    name: str
    version: str
    schema_type: str
    checksum: str
    relative_path: str


def detect_schema_type(path: Path) -> str:
    suffix = path.suffix.lower()
    if suffix in {".json", ".jsonld"}:
        return "JSON-LD" if suffix == ".jsonld" else "JSON"
    if suffix in {".yaml", ".yml"}:
        return "YAML"
    return suffix.strip(".") or "UNKNOWN"


def extract_version(data: dict) -> str:
    metadata = data.get("canonicalMetadata")
    if isinstance(metadata, dict):
        aeip_version = metadata.get("aeip_version")
        if aeip_version:
            return f"AEIP {aeip_version}"
        canonical_version = metadata.get("canonical_version")
        if canonical_version:
            return canonical_version
    return data.get("version", "v1.3")


def load_schema_records() -> list[SchemaRecord]:
    records: list[SchemaRecord] = []
    for path in sorted(AEIP_SCHEMA_DIR.iterdir()):
        if not path.is_file():
            continue
        checksum = hashlib.sha256(path.read_bytes()).hexdigest()
        schema_type = detect_schema_type(path)
        version = ""
        if path.suffix.lower() in {".json", ".jsonld"}:
            try:
                data = json.loads(path.read_text())
            except json.JSONDecodeError:
                data = {}
            version = extract_version(data)
        else:
            version = "AEIP 1.3"
        records.append(
            SchemaRecord(
                name=path.name,
                version=version,
                schema_type=schema_type,
                checksum=checksum,
                relative_path=f"../../schemas/aeip/{path.name}",
            )
        )
    return records


def write_schema_tables(records: list[SchemaRecord]) -> None:
    lines: list[str] = [
        "% \\begin{autogenerated}",
        "\\begin{autogenerated}",
        "\\subsection*{AEIP Schema Registry (v1.3)}",
        "\\begin{longtable}{p{0.25\\textwidth}p{0.15\\textwidth}p{0.15\\textwidth}p{0.35\\textwidth}}",
        "\\toprule",
        "\\textbf{Schema} & \\textbf{Version} & \\textbf{Type} & \\textbf{SHA-256 Checksum} \\ ",
        "\\midrule",
    ]
    for record in records:
        lines.append(
            f"\\texttt{{{record.name}}} & {latex_escape(record.version)} & {record.schema_type} & {record.checksum} \\ "
        )
        lines.append("\\midrule")
    lines[-1] = "\\bottomrule"
    lines.append("\\end{longtable}")
    lines.append("\\subsection*{Normative Schema Listings}")
    for record in records:
        lines.append(
            f"\\lstinputlisting[caption={{AEIP schema: {record.name}}}]{{{record.relative_path}}}"
        )
    lines.extend([
        "\\end{autogenerated}",
        "% \\end{autogenerated}",
        "",
    ])
    (APPENDIX_OUTPUT_DIR / "appendix-f-schema-registry.tex").write_text("\n".join(lines))


def main() -> None:
    ensure_dirs()
    layer_data = [LayerEntry.from_dict(item) for item in load_json(LAYER_DATA_PATH)["layers"]]
    write_layer_control_tables(layer_data)
    write_maturity_tables(load_json(MATURITY_DATA_PATH))
    write_schema_tables(load_schema_records())


if __name__ == "__main__":
    main()
